signals-seminar

man 7 signal — посмотреть все возможные сигналы

SIGUSR1
SIGUSR2

kill(pid,signo);
signal(signum, handler);

Вначале было реализовано так: имеется 32 бита, каждый соответствует какому-то сигналу. Sheduler смотрел, есть ли какой пришедший сигнал, и в зависимости от этого отправлял на обработчик сигналов.

Плохо тем, что если процессов, пославших сигнал, несколько, то невозможно определить их количество.

Поэтому сделали НОВЫЙ ИНТЕРФЕЙС сигналов.

  sigaction
  
  не битовая маска, а список, в который записываются обстоятельства прихода

  лимит существует, при его достижении ставится специальная метка.

void handler(int signo, siginfo *info, void*);

struct sigaction new_a, old_a;

memset(&new_a, 0, sizeof(new_a));
new_a.sa_sigaction=handler;

sigaction(signo, &new_a, &old_a); //old_a нужна для сохранения информации о старом обработчике.


-------------------
БЛОКИРОВКА.

Процесс может попросить систему не доставлять какие-то сигналы.

sigprocmask(how, new, old);

man sigemptyset; -- функции для удобной работы с масками

sigsuspend(mask) -- приостанавливает по приходе сигнала.


-----------------------
ДОСТАТОЧНО ВЕСЕЛОЕ ЗАДАНИЕ

prog1, prog2

первый процесс зачитывает файл и посылает второму содержимое "азбукой Морзе" -- единица SIGUSR1, ноль SIGUSR2, второй записывает содержимое в новый файл.

Подводные камни:

1. Договориться, когда второй процесс готов принимать сигналы -- поэтому маску нужно ставить до fork()
2. Забивание очереди: организация интерфейса подтверждений приёма сигнала.	//гигабайт секунд -- это очень много.
3. getppid() -- получить парентский pid.

Книжка Рыбачевского по UNIX

ещё:

замерить время.
посчитать md5-хэш.
реализовать завершение процессов (третий сигнал).
